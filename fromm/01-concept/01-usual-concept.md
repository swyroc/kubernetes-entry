# Concept
* Faas - Function as a service

# 服务注册 服务发现
```
为什么会衍生？
因为从巨石应用衍生到多层应用衍生到微服务，一个哪怕很简单的应用都可以被拆分成多个应用，拆分出来的每个应用都可以被一个微型团队自我迭代，互联网是粗暴的，面对着微服务，很多互联网公司甚至将一个简单的应用拆分成多个应用，原来的一个应用甚至被拆分成30到50个应用。
1. 30~50 - 微型微服务，那么这个对于运维来说简直就是噩梦。而且这些应用形成了复杂的网状模型。一个应用可能与多个其他的应用之间形成复杂的关系。
2. 非静态配置，动态服务发现 - 原有的服务与服务之间的调用都不是通过静态配置的方式来实现，动态服务发现就衍生了服务总线的概念。每个对外提供服务的应用都可以再总线上注册服务，一旦某个应用需要某种类型服务，那么该应用就可以到服务总线上去查找某个服务，通过调用接口的方式来访问提供服务的客户端，一旦某服务出现故障，那么总线就可以将该服务移除。所以总线只要没有问题，那么服务调用就不会有问题。
3. 服务编排 - 30个服务也同时诞生了一个问题就是服务部署，怎样将这些微服务规划并部署，也是一个问题。可以提供一组主机，这些主机上面运行服务编排系统，一旦某个服务需要部署，那么只需要将该服务编排系统提供给服务，那么服务编排系统就会自动的查询当前主机中最适合部署服务的主机，然后将应用服务部署上去。
4. 容器编排系统 - 不可避免的问题就是，肯定有特殊应用对自己的部署环境有一定的要求，比如当某些主机组成的集群中的任何一台主机都无法满足应用部署的需求的时候，那么此时部署就成为一个问题。可以让应用服务自身容器化，自带部署所需要的环境。服务编排系统面临最大的问题就是底层系统环境是否满足部署应用程序运行逻辑，那么容器化技术的出现刚好解决了这个问题。打包运行应用程序的方式-镜像，运行应用程序的方式-容器。简言之，通过docker打包应用程序，跑应用程序不是通过直接部署应用程序到底层，而是将应用程序的镜像下载到对应节点上，启动为容器，镜像自带了应用程序依赖的所有环境，因此可以一次打包到处运行，而无需再考虑底层应用环境异构与否。单一的容器没有价值，只有将容器编排之后，容器的价值才能发挥出来。
    docker解决了应用程序打包的难题，推动了容器技术的快速普及
    容器本身提供了托管应用程序应用的底层逻辑，容器编排Orchestration才是真正产生价值的所在。


```

## 容器编排系统 - Container Orchestration
* 容器编排系统用来管理容器的生命周期，特别是在大型的动态的环境中使用会更好
* 容器编排系统可以完成以下内容：
    a. 容器的提供和部署 - 如何获得容器镜像，如何部署容器，如何运行容器
    b. 容器的冗余和可用性 - 一旦容器发生故障，如何通过机制将容器自动的恢复过来，步骤必须是自动的
    c. 按需分配，扩容伸缩，如何根据某种机制自动的进行扩容和伸缩。节点不够扩容，资源闲置时缩容
    d. 一旦底层资源紧张，那么自动将容器迁移到别的节点，用户对此无感知
    e. 容器之间进行资源分配，甚至在某种情况下将集群内部的资源暴露到集群外部去，以便对外提供访问
    f. 负载均衡，以及容器之间的服务发现
    g. 健康监测-health check
    h. 应用程序的配置等
以上所有功能必须都是自动完成的。总结以下最主要的几个功能：
    a. Service Discovery
    b. Load Balancing
    c. Secrets/configuration/storage management
    d. Healthc checks
    f. Auto-Scaling/restart/healing of containers and hosts
    g. Zero-downtime deploys

### Docker Swarm 与K8S之间的比较
* Docker已死，含义是docker技术越来越火，可是docker这家公司却活不下去了快
* 为什么docker内置了docker swarm，但是docker官宣却说支持k8s？
* K8s的前生是google十几年前遇到容器编排问题而研发的内部项目Borg，只是当下使用golang语言重新开发了Borg产生了k8s，十几年的容器编排经验导致了google在容器编排领域趟过了无数的坑，积累了无数的经验，这点其实引人深思。
* Docker只是一家互联网公司，而其本身并不知道容器编排是为了解决什么，与google相比，太弱了。


